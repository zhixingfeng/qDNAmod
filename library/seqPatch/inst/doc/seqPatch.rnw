\documentclass[12pt]{article}
\SweaveOpts{keep.source=FALSE}
\title{seqPatch: a R package detecting DNA
modifications from SMRT sequencing data by modeling sequence context dependence of
polymerase kinetic}

\author{Zhixing Feng}

\begin{document}
\SweaveOpts{concordance=TRUE}
\maketitle
\section*{Introduction}
\emph{seqPatch} is a handy R package that implement SMRT sequencing based DNA modification detection method described in \cite{Feng2013}. \emph{seqPatch} can detect DNA modifications with or without control sample. The method use Inter-Pulse duration(IPD) generated by SMRT sequencing, which reflects kinetic of DNA polymerase and is sensitive to a wide range of DNA modifications, to detect DNA modifications. 

\section*{Prepare data}
\subsection*{Get alignment data by phb5}
\emph{seqPatch} depends on \emph{pbh5} Package, and its inputs are objects returned by function \emph{getAlignmentsWithFeatures} and \emph{alnIndex} in \emph{pbh5} package. We can get them by installing \emph{phb5} and running the following code(not really an executable example).
<<eval=FALSE>>=
### do NOT run it
library(pbh5)
cmpH5.native <- PacBioCmpH5(filename.native)
alnsF.native <- getAlignmentsWithFeatures(cmpH5.native, fxs=list(IPD=getIPD))
alnsIdx.native <- alnIndex(cmpH5.native)
cmpH5.ctrl <- PacBioCmpH5(filename.ctrl)
alnsF.ctrl <- getAlignmentsWithFeatures(cmpH5.ctrl, fxs=list(IPD=getIPD))
alnsIdx.ctrl <- alnIndex(cmpH5.ctrl)
@
where \emph{filename.native} is path of cmp.h5 file, which stores aligned reads as well as kinetic information of the native sample, generated by smrtpipe, and \emph{filename.ctrl} is for the control sample. $alnsF.native$ and $alnsF.ctrl$ contain alignments and kinetic information for each read, and $alnsIdx.native$ and $alnsIdx.ctrl$ contains other alignment information for each read, such as strand and genome positions it aligned to, name of reference genome(i.e. string after $>$ in fasta file of reference genome), etc.

\subsection*{pre-processing}
before detecting DNA modifications, IPD has to be Box-Cox transformed and normalized.
<<eval=FALSE>>=
library(seqPatch)
### do NOT run it
### load test data
load(paste(system.file(package = "seqPatch"), "/data/test.Rdata",sep = ""))

### Box-Cox transformation 
alnsF.native <- transformIPD(alnsF.native)
alnsF.ctrl <- transformIPD(alnsF.ctrl)

### normalization
alnsF.native <- normalizeBySubread(alnsF.native)
alnsF.ctrl <- normalizeBySubread(alnsF.native)
@
"transformIPD" transform IPD by Box-Cox transformation, where default parameters are $\alpha=0.005$ and $\lambda=0.16$ for C2 chemistry \cite{Feng2013}. The function "normalizeBySubread" normalizes each transformed IPD by substracting average transformed IPD of the subread it comes from. Another option for normalization is normalizing by movie (call function "normalizeByMovie" like the code listed below), which is described in section "Box-Cox transformation and normalization" in \cite{Feng2013}. NOTE: input of "normalizeBySubread" and "normalizeByMovie" must be Box-Cox transformed IPD (i.e one must call "transformIPD" before normalization).

<<eval=FALSE>>=
alnsF.native <- normalizeByMovie(alnsF.native, alnsIdx.native)
alnsF.ctrl <- normalizeByMovie(alnsF.ctrl, alnsIdx.ctrl)
@
\section*{Detect DNA modifications}

DNA sequence of reference genome is needed to detect modifications, which can be got by 
<<eval=FALSE>>=
### do NOT run it
genomeSeq <- getGenomeSeq(fastafilename)
@

For modification detection, if you have both control sample and historical data, you can use them both by the following code
<<eval=FALSE>>=
### do NOT run it
genomeF.native <- getFeaturesAlongGenome(alnsF.native, alnsIdx.native)
genomeF.ctrl <- getFeaturesAlongGenome(alnsF.ctrl, alnsIdx.ctrl)
detect.hieModel<- detectModification(genomeF.native, genomeF.ctrl, genomeSeq, context.effect,  method='hieModel', left.len=6, right.len=1)
@
This code would combine IPD in control sample (\emph{genomeF.ctrl}) and IPD of homologous positions(positions that have the same sequence context) in historical data (\emph{context.effect}, we will talk about how to get it in the next section) for detection. If you do NOT have a control sample, you can detect modifictions by only use IPD of homologous positions in historical data. The code is 
<<eval=FALSE>>=
detect.hieModel <- detectModification.NC(genomeF.native, genomeSeq, context.effect, method='hieModel', left.len=6, right.len=1)
@
detect.hieModel\$pos\$refname\$LR\_log is vector that contains log-likelihood ratio for each position in forward strand of the genome, where larger value means the very base is more likely to be modified. "refname" means the name of reference genome, for example, chr1, chr2, etc.  detect.hieModel\$genome.start.pos\$refname is the genome position of the first value of detect.hieModel\$pos\$refname\$LR\_log, and the positions of the left most base of a genome is 1. detect.hieModel\$neg contains the information for backward strand(forward strand and backward strand here are in "read" space, which is explained in Figure \ref{fig:read_space}).

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{fig/figure_1.png}
\caption{"Template"(shown in blue) is the DNA molecule that actually in the sequencing machine, and "Read"(shown in red) is sythesized DNA strand, which is recorded in output of PacBio' primary analysis pipeline (i.e. the .bas.h5 files). seqPatch works on "read" space, which means if result is a "T" in the forward strand is modified, the actually modified base is the complementary "A" in the backward strand (in the "template" space), and vice versa. 
}
\label{fig:read_space}
\end{figure} 

Note that "left.len" and "right.len" are number of upstream bases and number of downstream bases of sequence context respectively, the default values are left.len=6, right.len=1. One should make sure that they are the same with "left.len" and "right.len" in "getContextEffectByPos" described in the next section. 

\section*{Build your own "context.effect"}
Now we will show how to get \emph{context.effect} in the previous section. Firstly, we need to find a historical dataset that contains no modification(for example, whole genome amplified sample or sample lack of certain enzyme). Suppose the file name of that data is \emph{filename.historical}, we can \emph{context.effect} by the following code 
<<eval=FALSE>>=
library(seqPatch)
library(pbh5)
cmpH5.historical <- PacBioCmpH5(filename.historical)
alnsF.historical <- getAlignmentsWithFeatures(cmpH5.historical, features='IPD')
alnsIdx.historical <- alnIndex(cmpH5.historical)
genomeF.historical <- getFeaturesAlongGenome(alnsF.historical , alnsIdx.historical )
genomeSeq <- getGenomeSeq(fastafilename)
context.effect <- getContextEffectByPos(genomeF.historical, genomeSeq, left.len =6 ,right.len=1)
@
where left.len is number of upstream bases in sequence context, and right.len is for downstream bases.  \emph{context.effect} contains IPD of positions that have the context(i.e. homologous positions). 

\section*{An executable example}
Here we show an executable example to demonstrate how \emph{seqPatch} work.
<<eval=FALSE>>=
library(seqPatch)
### load data
load(paste(system.file(package = "seqPatch"), "/data/test.Rdata",sep = ""))
### load reference genome
genomeSeq <- getGenomeSeq(paste(system.file(package = "seqPatch"), "/data/refgenome.fasta",sep = ""))

alnsF.native <- transformIPD(alnsF.native, 0.02,-0.08)
alnsF.ctrl <- transformIPD(alnsF.ctrl, 0.02,-0.08)
alnsF.native <- normalizeByMovie(alnsF.native, alnsIdx.native)
alnsF.ctrl <- normalizeByMovie(alnsF.ctrl, alnsIdx.ctrl)

genomeF.native <- getFeaturesAlongGenome(alnsF.native, alnsIdx.native)
genomeF.ctrl <- getFeaturesAlongGenome(alnsF.ctrl, alnsIdx.ctrl)

detect.hieModel<- detectModification(genomeF.native, genomeF.ctrl, genomeSeq, context.effect,  method='hieModel', left.len=6, right.len=1)
detect.hieModel.NC <- detectModification.NC(genomeF.native, genomeSeq, context.effect, method='hieModel', left.len=6, right.len=1)
@

\section*{Practical recommendations}
SMRT sequencing is senstitive a wide range of DNA modifcations including m6A, m4C m5C etc. However, m6A have much stronger signal, and m4C has weaker signal, m5C has the weakest. For m6A and 8-oxoG, one don't need a whole genome amplified(WGA) sample (control sample), and can only use historical data to achieve good accuracy. However, one has to generate WGA sample to detect m4C accurately. Coverage has big impact on accuracy. For m6A, the recommanded coverage is 50x native sample, and for m4C, one need 100x native sample and 100x control sample. For all types of modificaitons, combining control sample and historical can always imcrease accuracy. 


\bibliographystyle{plos2009}
\bibliography{ref}
\end{document}



